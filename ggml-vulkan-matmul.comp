#version 450

#define BM 64
#define BN 64
#define BK 8
#define TM 8

#extension GL_EXT_control_flow_attributes : enable

layout(local_size_x = (BM * BN) / TM, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) readonly buffer A { float data_a[]; };
layout (binding = 1) readonly buffer B { float data_b[]; };
layout (binding = 2) writeonly buffer D { float data_d[]; };

layout (push_constant) uniform parameter
{
    int M;
    int N;
    int K;
    int stride_a;
    int stride_b;
    int stride_d;
} p;

shared float buf_a[BM * (BK+1)];
shared float buf_b[BN * (BK+1)];

void main() {
    const int ir = int(gl_WorkGroupID.x);
    const int ic = int(gl_WorkGroupID.y);

    const int lr = int(gl_LocalInvocationID.x % BK);
    const int lc = int(gl_LocalInvocationID.x / BK);

    int pos_a = ir * BM * p.stride_a;
    int pos_b = ic * BN * p.stride_b;

    float sums[TM];
    float btmp;

    [[unroll]] for (int k = 0; k < TM; k++) {
        sums[k] = 0.0f;
    }

    for (int i = 0; i < p.K; i += BK) {
        // A is transposed
        buf_a[lc * (BK+1) + lr] = data_a[pos_a + lc * p.stride_a + lr];
        buf_b[lc * (BK+1) + lr] = data_b[pos_b + lc * p.stride_b + lr];

        barrier();

        pos_a += BK;
        pos_b += BK;

        [[unroll]] for (int j = 0; j < BK; j++) {
            btmp = buf_b[lc * (BK+1) + j];
            [[unroll]] for (int k = 0; k < TM; k++) {
                sums[k] += buf_a[(lr * TM + k) * (BK+1) + j] * btmp;
            }
        }

        barrier();
    }

    const int dr = ir * BM + lr * TM;
    const int dc = ic * BN + lc;

    [[unroll]] for (int k = 0; k < TM; k++) {
        data_d[dc * p.stride_d + dr + k] = sums[k];
    }
}
